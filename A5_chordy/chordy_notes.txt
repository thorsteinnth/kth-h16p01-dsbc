Chordy: A distributed hash table

Implement chord storage
First implementation just a ring structure
Can add nodes to the ring but not add any elements to the store

Bæta svo failure detection í kerfið
ATH að við tröckum bara einn successor en actual chordy trackar nokkra

Replication í storeinu til að replicate-a data ef nodes deyja
"That will take care of some problems but does it actually work?"

Það þarf í raun ekki finger table í network of 20 nodes
(finger tables leyfa okkur að finna any given key in log(n) hops)
(annars linear search ef þær eru ekki til staðar)

If you also want to implement mutable objects you will be faced with
a challenge. Hvernig update-ar maður object (consistently) ef hann er
replicated? Some nodes might be unavailable during node insertion and failures.
To solve this you will have to do some more reading.

-----------------------------------------------------------------------------------

1 Building a ring

Notum ekki hash function heldur bara random number sem er generated þegar new key
er generated
Engin "names" á nodes, bara random numbers sem við vonum að séu unique.
"Using a hash function such as SHA-1 would give us 160 bits and allow us to have
human readable names on object but let’s keep things simple."

Key module:
TODO
Remember that the we’re dealing with a ring so it could be that From is larger than To.
What does that mean and how do you handle it?

TODO
If you study the Chord paper you will find that they explain things slightly different.
We use our key:between/3 function that allows the key Xkey to be equal to Skey,
not strictly according to the paper.
Does this matter? What does it mean that Xkey is equal to Skey, will it ever happen?

TODO
What are the pros and cons of a more frequent stabilizing procedure?
What is delayed if we don’t do stabilizing that often?

TODO
notify/3
Do we need a special case to detect that we’re pointing to ourselves?
Do we have to inform the new node about our decision?
How will it know if we have discarded its friendly proposal?

TODO
What would happen if we didn’t schedule the stabilize procedure (when a node is started)?
Would things still work?

---------------------------------------------------------------------------------------------------

111016 0023
Eitthvað rugl í stabilize

[<0.70.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {443584618,<0.70.0>}}
[<0.71.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {723040206,<0.71.0>}}
[<0.72.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {945816365,<0.72.0>}}
[<0.73.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {501490715,<0.73.0>}}
[<0.74.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {311326755,<0.74.0>}}
[<0.75.0>] ENTERED STABILIZE WITH SUCCESSOR ARG AS: {notify,
                                                     {597447525,<0.75.0>}}
[<0.70.0>] TRYING TO SEND REQUEST TO: {443584618,<0.70.0>}
[<0.71.0>] TRYING TO SEND REQUEST TO: {723040206,<0.71.0>}
[<0.72.0>] TRYING TO SEND REQUEST TO: {945816365,<0.72.0>}
[<0.73.0>] TRYING TO SEND REQUEST TO: {501490715,<0.73.0>}
[<0.74.0>] TRYING TO SEND REQUEST TO: {311326755,<0.74.0>}
[<0.75.0>] TRYING TO SEND REQUEST TO: {597447525,<0.75.0>}

=ERROR REPORT==== 11-Oct-2016::00:22:02 ===
Error in process <0.70.0> with exit value:
{badarg,[{node1,stabilize,1,[{file,"node1.erl"},{line,182}]},
         {node1,node,3,[{file,"node1.erl"},{line,81}]}]}

Vandinn var að ég var ekki að returna successor úr stabilize/3
Virðist vera að virka núna. Probe-inn fer í gegnum hækkandi röð af keys.
ATH engar ring repairs komnar í þetta

---------------------------------------------------------------------------------------------------

111016 2011
Kominn með ring up and running
"Adding a store" er næst

---------------------------------------------------------------------------------------------------

Adda í store virðist vera að virka
Búa til nodes, adda values, adda more nodes, gildi dreifast rétt

86> test:testStore2().
[<0.457.0>] Received my own probe - Created time: 1476225499697593 - Current time: 1476225499697633 - Nodes: [{912868469,
                                                                                                               <0.457.0>},
                                                                                                              {110309381,
                                                                                                               <0.458.0>},
                                                                                                              {679406574,
                                                                                                               <0.459.0>}]
[<0.458.0>] STORE: [{97462353,value4}]
[<0.457.0>] STORE: [{834748490,value1},{827307409,value3}]
[<0.459.0>] STORE: [{636626494,value2}]
[<0.457.0>] Received my own probe - Created time: 1476225529711087 - Current time: 1476225529711124 - Nodes: [{912868469,
                                                                                                               <0.457.0>},
                                                                                                              {78154561,
                                                                                                               <0.463.0>},
                                                                                                              {110309381,
                                                                                                               <0.458.0>},
                                                                                                              {174207268,
                                                                                                               <0.462.0>},
                                                                                                              {521769722,
                                                                                                               <0.464.0>},
                                                                                                              {679406574,
                                                                                                               <0.459.0>},
                                                                                                              {740003928,
                                                                                                               <0.461.0>},
                                                                                                              {867833725,
                                                                                                               <0.460.0>}]
[<0.457.0>] STORE: []
[<0.458.0>] STORE: [{97462353,value4}]
[<0.459.0>] STORE: [{636626494,value2}]
[<0.460.0>] STORE: [{834748490,value1},{827307409,value3}]
[<0.461.0>] STORE: []
[<0.462.0>] STORE: []
[<0.463.0>] STORE: []
[<0.464.0>] STORE: []
ok

-----

93> test:testStore2().
[<0.508.0>] Received my own probe - Created time: 1476226449068516 - Current time: 1476226449068529 - Nodes: [{217489552,
                                                                                                               <0.508.0>},
                                                                                                              {579315200,
                                                                                                               <0.509.0>},
                                                                                                              {946799514,
                                                                                                               <0.510.0>}]
[<0.508.0>] STORE: [{93868016,value2},{99422912,value3}]
[<0.509.0>] STORE: [{479668684,value1},{318713296,value4}]
[<0.510.0>] STORE: []
[<0.508.0>] Received my own probe - Created time: 1476226479072934 - Current time: 1476226479072975 - Nodes: [{217489552,
                                                                                                               <0.508.0>},
                                                                                                              {339507846,
                                                                                                               <0.514.0>},
                                                                                                              {579315200,
                                                                                                               <0.509.0>},
                                                                                                              {600784579,
                                                                                                               <0.513.0>},
                                                                                                              {755193177,
                                                                                                               <0.511.0>},
                                                                                                              {778618308,
                                                                                                               <0.512.0>},
                                                                                                              {824062636,
                                                                                                               <0.515.0>},
                                                                                                              {946799514,
                                                                                                               <0.510.0>}]
[<0.508.0>] STORE: [{93868016,value2},{99422912,value3}]
[<0.509.0>] STORE: [{479668684,value1}]
[<0.510.0>] STORE: []
[<0.511.0>] STORE: []
[<0.512.0>] STORE: []
[<0.513.0>] STORE: []
[<0.514.0>] STORE: [{318713296,value4}]
[<0.515.0>] STORE: []
LOOKUP RESULTS: {479668684,value1} {93868016,value2} {99422912,value3} {318713296,
                                                                        value4}
ok

gildin eru að fara á rétta staði og ég get lookupað þau aftur

---------------------------------------------------------------------------------------------------

2.6 Performance

If we now have a distributed store that can handle new nodes that are added to the ring we might
try some performance testing.

You need to be a group with several machine to do this.

Assume that we have eight machines and that we will use four in building the ring and four in testing the performance.

TODO
As a first test we can have one node only in the ring and let the four test machines add 1000 elements to the ring
and then do a lookup of the elements.
Does it take longer for one machine to handle 4000 elements rather than
four machines that do 1000 elements each. What is the limiting factor?

Implement a test procedure that adds a number of random key-value pairs into the system and keeps the keys in a list.
You should then be able to do a lookup of all the keys and measure the time it takes.
The lookup test should be given the name of a node to contact.

TODO
Now what happens if we add another node to the ring, how does the performance change?

TODO
Does it matter if all test machines access the same node?

TODO
Add two more nodes to the ring, any changes?

TODO
How will things change if we have a ten thousand elements?

PERFORMANCE TEST RESULTS
Er ekki að keyra þetta á mörgum vélum eins og hann vill
Make multiple processes add 1000 elements at the same time, simulate many computers

-------------------------------

1, 1, 1000:

23> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 3 ms
0 lookups failed, 0 caused a timeout
24> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
25> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
26> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 3 ms
0 lookups failed, 0 caused a timeout
27> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
28> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
29> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 3 ms
0 lookups failed, 0 caused a timeout
30> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
31> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 4 ms
0 lookups failed, 0 caused a timeout
32> test:performanceTest(1, 1, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 1000
Starting test machine worker 1
ok
1000 lookup operation in 3 ms
0 lookups failed, 0 caused a timeout

------------------------------------------------

As a first test we can have one node only in the ring and let the four test machines add 1000 elements to the ring
and then do a lookup of the elements.
Does it take longer for one machine to handle 4000 elements rather than four machines that do 1000 elements each.
What is the limiting factor?

1 - 4 - 1000

33> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 21 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
34> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
35> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 23 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
36> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 22 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
37> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 23 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
38> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 25 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
39> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 26 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 17 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 17 ms
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
40> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 27 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
1000 lookup operation in 19 ms
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
41> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 23 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 15 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
42> test:performanceTest(1, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 24 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 15 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout

-----------------------------------------------------------

1 - 1 - 4000

2> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
3> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 25 ms
0 lookups failed, 0 caused a timeout
4> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
5> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
6> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 26 ms
0 lookups failed, 0 caused a timeout
7> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
8> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
9> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
10> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 26 ms
0 lookups failed, 0 caused a timeout
11> test:performanceTest(1, 1, 4000).
Sleeping (to stabilize ring)
Running performance test - N: 1 - Testmachines: 1 - Elements: 4000
Starting test machine worker 1
ok
4000 lookup operation in 25 ms
0 lookups failed, 0 caused a timeout

TODO
Does it take longer for one machine to handle 4000 elements rather than four machines that do 1000 elements each.
What is the limiting factor?

-----------------------------------------------

Now what happens if we add another node to the ring, how does the performance change?

2 - 4 - 1000

12> test:performanceTest(2, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 2 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 22 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 19 ms
0 lookups failed, 0 caused a timeout
13> test:performanceTest(2, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 2 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 14 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 15 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 15 ms
0 lookups failed, 0 caused a timeout
14> test:performanceTest(2, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 2 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
15> test:performanceTest(2, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 2 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 28 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 21 ms
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
1000 lookup operation in 20 ms
0 lookups failed, 0 caused a timeout
16> test:performanceTest(2, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 2 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout

----------------------------------------------------------------------------------

Does it matter if all test machines access the same node?
Nenni ekki að testa þetta - þarf að breyta test fallinu

----------------------------------------------------------------------------------

Add two more nodes to the ring, any changes?

4 - 4 - 1000

22> test:performanceTest(4, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
23> test:performanceTest(4, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
24> test:performanceTest(4, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 18 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 17 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 17 ms
0 lookups failed, 0 caused a timeout
25> test:performanceTest(4, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 21 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 21 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 22 ms
1000 lookup operation in 22 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
26> test:performanceTest(4, 4, 1000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 1000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
1000 lookup operation in 22 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 17 ms
0 lookups failed, 0 caused a timeout
1000 lookup operation in 16 ms
0 lookups failed, 0 caused a timeout

-------------------------------------------------------------------------------------

How will things change if we have a ten thousand elements?

4 - 4 - 1000

44> test:performanceTest(4, 4, 10000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 10000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
10000 lookup operation in 528 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 495 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 496 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 490 ms
0 lookups failed, 0 caused a timeout
45> test:performanceTest(4, 4, 10000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 10000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
10000 lookup operation in 776 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 747 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 745 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 746 ms
0 lookups failed, 0 caused a timeout
46> test:performanceTest(4, 4, 10000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 10000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
10000 lookup operation in 529 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 533 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 534 ms
10000 lookup operation in 526 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
47> test:performanceTest(4, 4, 10000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 10000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
10000 lookup operation in 485 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 487 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 486 ms
10000 lookup operation in 487 ms
0 lookups failed, 0 caused a timeout
0 lookups failed, 0 caused a timeout
48> test:performanceTest(4, 4, 10000).
Sleeping (to stabilize ring)
Running performance test - N: 4 - Testmachines: 4 - Elements: 10000
Starting test machine worker 4
Starting test machine worker 3
Starting test machine worker 2
Starting test machine worker 1
ok
10000 lookup operation in 627 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 581 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 586 ms
0 lookups failed, 0 caused a timeout
10000 lookup operation in 585 ms
0 lookups failed, 0 caused a timeout

----------------------------------------------------------------------------------------------------------------------

3 First optional task for extra bonus: Handling failures

To handle failures we need to detect if a node has failed.
Both the successor and the predecessor need to detect this and we will use the Erlang built-in procedure
to monitor the health of a node.
Start a new module node3 and copy what we have from node2.

Keep track of successor's successor (Next).
NOTE: Only one safety pointer - can't handle two nodes in a row crashing

Monitora successor og predecessor
Vista þá sem {Key, Ref, Pid} tuples where the Ref is a reference produced by the monitor procedure.

Þegar ég sendi messages á milli nóða sendi ég ekki Refið.
When a new node is adopted as successor or predecessor we need to demonitor the old node and monitor the new
Hvar breytast successor og predecessorarnir mínir?
4 staðir þar sem ég þarf að monitora - DONE
2 staðir þar sem ég þarf að de-monitora - DONE

----

Node3 tests

27> test:testNode3().
[<0.235.0>] Received my own probe - Created time: 1476291059352762 - Current time: 1476291059352792 - Nodes: [{134660158,
                                                                                                               <0.235.0>},
                                                                                                              {165857176,
                                                                                                               <0.236.0>},
                                                                                                              {236005157,
                                                                                                               <0.237.0>},
                                                                                                              {271543407,
                                                                                                               <0.241.0>},
                                                                                                              {333638099,
                                                                                                               <0.240.0>},
                                                                                                              {453243160,
                                                                                                               <0.242.0>},
                                                                                                              {772208333,
                                                                                                               <0.239.0>},
                                                                                                              {920282593,
                                                                                                               <0.238.0>}]
Stopping node 1 - PID: <0.235.0>
Stopping node 3 - PID: <0.237.0>
Stopping node 7 - PID: <0.241.0>
[<0.242.0>] Received my own probe - Created time: 1476291074354916 - Current time: 1476291074354997 - Nodes: [{453243160,
                                                                                                               <0.242.0>},
                                                                                                              {772208333,
                                                                                                               <0.239.0>},
                                                                                                              {920282593,
                                                                                                               <0.238.0>},
                                                                                                              {165857176,
                                                                                                               <0.236.0>},
                                                                                                              {333638099,
                                                                                                               <0.240.0>}]
probe

WORKS - ring recovers after killing some members of it

----

You’re done you have a fault tolerant distributed storage...... well almost,
if a node dies it will bring with it a part of the storage.
If this is ok we could stop here, if not we have to do some more work.

TODO
Another thing to ponder is what will happen if a node is falsely detected of being dead?
What will happen if a node has only been temporally unavailable
(and in the worst case, it might think that the rest of the network is gone).
How much would you gamble in trusting the ’DOWN’ message?

----------------------------------------------------------------------------------------------------------------------

4 Second option task for extra bonus: Replication

Les þetta bara, ekki að fara að gera þetta líka, kominn með bónusinn
Hunsa líka spurningarnar í þessum kafla í skýrslunni held ég

Replicate data to keep it if a node dies

Let's only handle failure of one node (one replica)
Replicate the store to the successor

When we add an key-value element to our own store we also forward it to our successor
as a {replicate, Key, Value} message.
Each node will thus have a second store called the Replica where it can keep a duplicate of its predecessors store.
When a new node joins the ring it will as before takeover part of the store but also part of the replica.
If a node dies it’s successor is of course responsible for the store held by the node.
This mean that the Replica should be merged with its own Store.

TODO
What does it mean that a element has been added to the store.
Can we send a confirmation to the client and then replicate the element, what if we fail?

If we want to handle failures we should make sure that a confirmation only is sent when
an element has been properly added and replicated.
TODO
This should not be too difficult to implement, who should send the confirmation?

A client that does not receive a confirmation could of course choose to re-send the message.
TODO
What happens if the element was added the first time but that the confirmation message was lost?
TODO
Will we handle duplicates properly?

TODO
Another problem has to do with a joining node in combination with adding of a new value.
You have to think about this twice before realizing that we have a problem. What would a solution look like?

TODO
Are there more devils?
Will we have a implementation with no obvious faults or an implantation with obviously no faults?

----------------------------------------------------------------------------------------------------------------------

5 Carrying on

Routing
Routing is one thing that we have left out completely.
If we only have twenty nodes it is less of a problem but if we have hundred nodes it does become important.
If network latency is high (think global Internet distances) then we need to do something.

TODO
Should we even try to take network distances into account and route to nodes that are network wise close to us
(remember that the ring is an over lay and does not say anything about network distance).


Replication

TODO
Is one replica enough or should we have two or three replicas? On what does this depend?
It is of course related to how reliable nodes are and what reliability we need to provide,
TODO
is it also dependent on the number of nodes in the ring?
TODO
Can we use the replicas for read operations and thus make use of the redundancy.
TODO
How are replicas found and can we distribute them in the ring to avoid hot-spots?

Mutable objects
As long as we only have one copy of an object things are simple,
but what if we want to update objects and some replicas are not updated.
TODO
Do we have to use a two-phase-commit protocol to update all replicas in a consistent way?
TODO
Could we have a trade off between the expense of read and write operations?
TODO
How relaxed can we be and how does this relate to a shopping cart?

----------------------------------------------------------------------------------------------------------------------

6 Conclusions

If you have followed this tutorial implementation you should have a better understanding of
how distributed hash tables work and how they are implemented.
As you have seen its not that hard to maintain a ring structure even in the face of failures.
A distributed store also seams easy to implement and replication could probably be solved.
Consistency is a problem, can we guarantee that added values never are lost (given a maximum number of failed nodes).
When things get complicate to implement the performance might suffer.

TODO
What is the advantage of the distributed store, is it performance or fault tolerance?
What should we optimize if we have to choose between them.






















